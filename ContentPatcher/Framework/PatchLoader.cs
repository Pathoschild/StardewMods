using System;
using System.Collections.Generic;
using System.Linq;
using ContentPatcher.Framework.Conditions;
using ContentPatcher.Framework.ConfigModels;
using ContentPatcher.Framework.Lexing;
using ContentPatcher.Framework.Lexing.LexTokens;
using ContentPatcher.Framework.Patches;
using ContentPatcher.Framework.Tokens;
using ContentPatcher.Framework.Tokens.Json;
using Newtonsoft.Json.Linq;
using Pathoschild.Stardew.Common;
using Pathoschild.Stardew.Common.Utilities;
using StardewModdingAPI;

namespace ContentPatcher.Framework
{
    /// <summary>Handles loading and unloading patches for content packs.</summary>
    internal class PatchLoader
    {
        /*********
        ** Fields
        *********/
        /// <summary>Manages loaded patches.</summary>
        private readonly PatchManager PatchManager;

        /// <summary>Manages loaded tokens.</summary>
        private readonly TokenManager TokenManager;

        /// <summary>The monitor through which to log errors.</summary>
        private readonly IMonitor Monitor;

        /// <summary>Simplifies access to private code.</summary>
        private readonly IReflectionHelper Reflection;

        /// <summary>The installed mod IDs.</summary>
        private readonly InvariantHashSet InstalledMods;

        /// <summary>Normalize an asset name so it's consistent with those generated by the game.</summary>
        private readonly Func<string, string> NormalizeAssetName;


        /*********
        ** Public methods
        *********/
        /// <summary>Construct an instance.</summary>
        /// <param name="patchManager">Manages loaded patches.</param>
        /// <param name="tokenManager">Manages loaded tokens.</param>
        /// <param name="monitor">The monitor through which to log errors.</param>
        /// <param name="reflection">Simplifies access to private code.</param>
        /// <param name="installedMods">The installed mod IDs.</param>
        /// <param name="normalizeAssetName">Normalize an asset name so it's consistent with those generated by the game.</param>
        public PatchLoader(PatchManager patchManager, TokenManager tokenManager, IMonitor monitor, IReflectionHelper reflection, InvariantHashSet installedMods, Func<string, string> normalizeAssetName)
        {
            this.PatchManager = patchManager;
            this.TokenManager = tokenManager;
            this.Monitor = monitor;
            this.Reflection = reflection;
            this.InstalledMods = installedMods;
            this.NormalizeAssetName = normalizeAssetName;
        }

        /// <summary>Load patches for a content pack.</summary>
        /// <param name="contentPack">The content pack for which to load patches.</param>
        /// <param name="rawPatches">The raw patches to load.</param>
        /// <param name="path">The path to the patches from the root content file.</param>
        /// <param name="reindex">Whether to reindex the patch list immediately.</param>
        /// <param name="parentPatch">The parent <see cref="PatchType.Include"/> patch for which the patches are being loaded, if any.</param>
        public void LoadPatches(RawContentPack contentPack, PatchConfig[] rawPatches, LogPathBuilder path, bool reindex, Patch parentPatch)
        {
            // get fake patch context (so patch tokens are available in patch validation)
            ModTokenContext modContext = this.TokenManager.TrackLocalTokens(contentPack.ManagedPack);
            LocalContext fakePatchContext = new LocalContext(contentPack.Manifest.UniqueID, parentContext: modContext);
            fakePatchContext.SetLocalValue(ConditionType.FromFile.ToString(), "");
            fakePatchContext.SetLocalValue(ConditionType.Target.ToString(), "");
            fakePatchContext.SetLocalValue(ConditionType.TargetPathOnly.ToString(), "");
            fakePatchContext.SetLocalValue(ConditionType.TargetWithoutPath.ToString(), "");

            // get token parser for fake context
            TokenParser tokenParser = new TokenParser(fakePatchContext, contentPack.Manifest, contentPack.Migrator, this.InstalledMods);

            // ignore null patches with a warning
            PatchConfig[] patches = rawPatches
                .Where((patch, i) =>
                {
                    bool isValid = patch != null;
                    if (!isValid)
                        this.Monitor.Log($"Ignored {path.With($"patch at index {i}")}: patch is null.", LogLevel.Warn);
                    return isValid;
                })
                .ToArray();

            // preprocess patches
            patches = this.SplitPatches(patches).ToArray();
            this.NamePatches(patches);

            // load patches
            foreach (PatchConfig patch in patches)
            {
                var localPath = path.With(patch.LogName);
                this.Monitor.VerboseLog($"   loading {localPath}...");
                this.LoadPatch(contentPack, patch, tokenParser, localPath, reindex: false, parentPatch, logSkip: reasonPhrase => this.Monitor.Log($"Ignored {localPath}: {reasonPhrase}", LogLevel.Warn));
            }

            // rebuild indexes
            if (reindex)
                this.PatchManager.Reindex(patchListChanged: true);
        }

        /// <summary>Unload patches loaded (directly or indirectly) by the given patch.</summary>
        /// <param name="parentPatch">The parent patch for which to unload descendants.</param>
        /// <param name="reindex">Whether to reindex the patch list immediately if it changed.</param>
        public void UnloadPatchesLoadedBy(IPatch parentPatch, bool reindex)
        {
            this.UnloadPatches(patch => this.IsDescendant(parent: parentPatch, child: patch), reindex);
        }

        /// <summary>Unload patches loaded (directly or indirectly) by the given content pack.</summary>
        /// <param name="pack">The content pack for which to unload descendants.</param>
        /// <param name="reindex">Whether to reindex the patch list immediately if it changed.</param>
        public void UnloadPatchesLoadedBy(RawContentPack pack, bool reindex)
        {
            this.UnloadPatches(patch => patch.ContentPack == pack.ManagedPack, reindex);
        }

        /// <summary>Normalize and parse the given condition values.</summary>
        /// <param name="raw">The raw condition values to normalize.</param>
        /// <param name="tokenParser">Handles low-level parsing and validation for tokens.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="conditions">The normalized conditions.</param>
        /// <param name="immutableRequiredModIDs">The immutable mod IDs always required by these conditions (if they're <see cref="ConditionType.HasMod"/> and immutable).</param>
        /// <param name="error">An error message indicating why normalization failed.</param>
        public bool TryParseConditions(InvariantDictionary<string> raw, TokenParser tokenParser, LogPathBuilder path, out IList<Condition> conditions, out InvariantHashSet immutableRequiredModIDs, out string error)
        {
            conditions = new List<Condition>();
            immutableRequiredModIDs = new InvariantHashSet();

            // no conditions
            if (raw == null || !raw.Any())
            {
                error = null;
                return true;
            }

            // parse conditions
            Lexer lexer = new Lexer();
            foreach (KeyValuePair<string, string> pair in raw)
            {
                if (!this.TryParseCondition(pair.Key, pair.Value, tokenParser, lexer, path.With(pair.Key), out Condition condition, out InvariantHashSet localImmutableRequiredModIDs, out error))
                {
                    conditions = null;
                    return false;
                }

                if (localImmutableRequiredModIDs != null)
                {
                    foreach (string id in localImmutableRequiredModIDs)
                        immutableRequiredModIDs.Add(id);
                }
                conditions.Add(condition);
            }

            error = null;
            return true;
        }


        /*********
        ** Private methods
        *********/
        /// <summary>Split patches with multiple target values.</summary>
        /// <param name="patches">The patches to split.</param>
        private IEnumerable<PatchConfig> SplitPatches(IEnumerable<PatchConfig> patches)
        {
            foreach (PatchConfig patch in patches)
            {
                if (string.IsNullOrWhiteSpace(patch.Target) || !patch.Target.Contains(","))
                {
                    yield return patch;
                    continue;
                }

                foreach (string target in patch.Target.Split(',').Select(p => p.Trim()).Distinct(StringComparer.OrdinalIgnoreCase))
                {
                    if (string.IsNullOrWhiteSpace(target))
                        continue;

                    yield return new PatchConfig(patch)
                    {
                        LogName = !string.IsNullOrWhiteSpace(patch.LogName) ? $"{patch.LogName} > {target}" : "",
                        Target = target
                    };
                }
            }
        }

        /// <summary>Set a unique name for all patches in a content pack.</summary>
        /// <param name="patches">The patches to name.</param>
        private void NamePatches(PatchConfig[] patches)
        {
            // add default log names
            foreach (PatchConfig patch in patches)
            {
                if (string.IsNullOrWhiteSpace(patch.LogName))
                {
                    if (Enum.TryParse(patch.Action, ignoreCase: true, out PatchType type) && type == PatchType.Include)
                        patch.LogName = $"{type} {PathUtilities.NormalizePathSeparators(patch.FromFile)}";
                    else
                        patch.LogName = $"{patch.Action} {PathUtilities.NormalizePathSeparators(patch.Target)}";
                }
            }

            // make names unique within content pack
            foreach (var patchGroup in patches.GroupBy(p => p.LogName, StringComparer.OrdinalIgnoreCase).Where(p => p.Count() > 1))
            {
                int i = 0;
                foreach (PatchConfig patch in patchGroup)
                    patch.LogName += $" #{++i}";
            }
        }

        /// <summary>Unload patches matching a condition.</summary>
        /// <param name="where">Matches patches to unload.</param>
        /// <param name="reindex">Whether to reindex the patch list immediately if it changed.</param>
        private void UnloadPatches(Func<IPatch, bool> where, bool reindex)
        {
            IPatch[] removePatches = this.PatchManager.GetPatches().Where(where).ToArray();
            if (removePatches.Any())
            {
                foreach (IPatch patch in removePatches)
                    this.PatchManager.Remove(patch, reindex: false);

                if (reindex)
                    this.PatchManager.Reindex(patchListChanged: true);
            }
        }

        /// <summary>Load one patch from a content pack's <c>content.json</c> file.</summary>
        /// <param name="rawContentPack">The content pack being loaded.</param>
        /// <param name="entry">The change to load.</param>
        /// <param name="tokenParser">Handles low-level parsing and validation for tokens.</param>
        /// <param name="path">The path to the patch from the root content file.</param>
        /// <param name="reindex">Whether to reindex the patch list immediately.</param>
        /// <param name="parentPatch">The parent <see cref="PatchType.Include"/> patch for which the patches are being loaded, if any.</param>
        /// <param name="logSkip">The callback to invoke with the error reason if loading it fails.</param>
        private bool LoadPatch(RawContentPack rawContentPack, PatchConfig entry, TokenParser tokenParser, LogPathBuilder path, bool reindex, Patch parentPatch, Action<string> logSkip)
        {
            var pack = rawContentPack.ManagedPack;
            PatchType? action = null;

            bool TrackSkip(string reason, bool warn = true)
            {
                reason = reason.TrimEnd('.', ' ');
                this.PatchManager.AddPermanentlyDisabled(new DisabledPatch(path, entry.Action, action, entry.Target, pack, parentPatch, reason));
                if (warn)
                    logSkip(reason + '.');
                return false;
            }

            try
            {
                // normalize patch fields
                entry.When ??= new InvariantDictionary<string>();

                // parse action
                {
                    if (!Enum.TryParse(entry.Action, true, out PatchType parsedAction))
                    {
                        return TrackSkip(string.IsNullOrWhiteSpace(entry.Action)
                            ? $"must set the {nameof(PatchConfig.Action)} field"
                            : $"invalid {nameof(PatchConfig.Action)} value '{entry.Action}', expected one of: {string.Join(", ", Enum.GetNames(typeof(PatchType)))}"
                        );
                    }
                    action = parsedAction;
                }

                // parse conditions
                IList<Condition> conditions;
                InvariantHashSet immutableRequiredModIDs;
                {
                    if (!this.TryParseConditions(entry.When, tokenParser, path.With(nameof(entry.When)), out conditions, out immutableRequiredModIDs, out string error))
                        return TrackSkip($"the {nameof(PatchConfig.When)} field is invalid: {error}");
                }

                // parse target asset
                IManagedTokenString targetAsset = null;
                if (action != PatchType.Include)
                {
                    if (string.IsNullOrWhiteSpace(entry.Target))
                        return TrackSkip($"must set the {nameof(PatchConfig.Target)} field");
                    if (!tokenParser.TryParseString(entry.Target, immutableRequiredModIDs, path.With(nameof(entry.Target)), out string error, out targetAsset))
                        return TrackSkip($"the {nameof(PatchConfig.Target)} is invalid: {error}");
                }

                // parse 'enabled'
                bool enabled = true;
                {
                    if (entry.Enabled != null && !this.TryParseEnabled(entry.Enabled, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.Enabled)), out string error, out enabled))
                        return TrackSkip($"invalid {nameof(PatchConfig.Enabled)} value '{entry.Enabled}': {error}");
                }

                // parse update rate
                UpdateRate updateRate = UpdateRate.OnDayStart;
                if (entry.Update != null)
                {
                    if (!Enum.TryParse(entry.Update, true, out updateRate))
                        return TrackSkip($"Invalid {nameof(PatchConfig.Update)} value '{entry.Update}', expected one of: {string.Join(", ", Enum.GetNames(typeof(UpdateRate)))}");
                }

                // parse 'from file'
                IManagedTokenString fromAsset = null;
                if (entry.FromFile != null)
                {
                    if (!this.TryPrepareLocalAsset(entry.FromFile, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.FromFile)), out string error, out fromAsset))
                        return TrackSkip(error);
                }

                // validate field reference tokens
                if (targetAsset != null)
                {
                    if (targetAsset.UsesTokens(ConditionType.Target, ConditionType.TargetPathOnly, ConditionType.TargetWithoutPath))
                        return TrackSkip($"circular field reference: {nameof(entry.Target)} field can't use the '{ConditionType.Target}', '{ConditionType.TargetPathOnly}', or '{ConditionType.TargetWithoutPath}' tokens.");
                }
                if (fromAsset != null)
                {
                    if (fromAsset.UsesTokens(ConditionType.Target, ConditionType.TargetPathOnly, ConditionType.TargetWithoutPath) && targetAsset.UsesTokens(ConditionType.FromFile))
                        return TrackSkip($"circular field reference: {nameof(entry.Target)} field can't use the '{ConditionType.FromFile}' token if the {nameof(entry.FromFile)} field uses the '{ConditionType.Target}', '{ConditionType.TargetPathOnly}', or '{ConditionType.TargetWithoutPath}' tokens.");
                    if (fromAsset.UsesTokens(ConditionType.FromFile))
                        return TrackSkip($"circular field reference: {nameof(entry.FromFile)} field can't use the '{ConditionType.FromFile}' token.");
                }

                // get patch instance
                IPatch patch;
                switch (action)
                {
                    // include
                    case PatchType.Include:
                        {
                            // validate
                            if (fromAsset == null)
                                return TrackSkip($"must set the {nameof(PatchConfig.FromFile)} field for a {PatchType.Include} patch.");

                            // save
                            patch = new IncludePatch(
                                path: path,
                                assetName: null,
                                conditions: conditions,
                                fromFile: fromAsset,
                                updateRate: updateRate,
                                contentPack: rawContentPack,
                                parentPatch: parentPatch,
                                normalizeAssetName: this.NormalizeAssetName,
                                monitor: this.Monitor,
                                patchLoader: this
                            );
                        }
                        break;

                    // load asset
                    case PatchType.Load:
                        {
                            // validate
                            if (fromAsset == null)
                                return TrackSkip($"must set the {nameof(PatchConfig.FromFile)} field for a {PatchType.Load} patch.");

                            // save
                            patch = new LoadPatch(
                                path: path,
                                assetName: targetAsset,
                                conditions: conditions,
                                localAsset: fromAsset,
                                updateRate: updateRate,
                                contentPack: pack,
                                parentPatch: parentPatch,
                                normalizeAssetName: this.NormalizeAssetName
                            );
                        }
                        break;

                    // edit data
                    case PatchType.EditData:
                        {
                            // validate
                            if (entry.Entries == null && entry.Fields == null && entry.MoveEntries == null && fromAsset == null)
                                return TrackSkip($"one of {nameof(PatchConfig.Entries)}, {nameof(PatchConfig.Fields)}, {nameof(PatchConfig.MoveEntries)}, or {nameof(PatchConfig.FromFile)} must be specified for an '{action}' change");
                            if (fromAsset != null && (entry.Entries != null || entry.Fields != null || entry.MoveEntries != null))
                                return TrackSkip($"{nameof(PatchConfig.FromFile)} is mutually exclusive with {nameof(PatchConfig.Entries)}, {nameof(PatchConfig.Fields)}, and {nameof(PatchConfig.MoveEntries)}");

                            // parse data changes
                            bool TryParseFields(IContext context, PatchConfig rawFields, out List<EditDataPatchRecord> parsedEntries, out List<EditDataPatchField> parsedFields, out List<EditDataPatchMoveRecord> parsedMoveEntries, out string parseError)
                            {
                                return this.TryParseEditDataFields(rawFields, tokenParser, immutableRequiredModIDs, path, out parsedEntries, out parsedFields, out parsedMoveEntries, out parseError);
                            }
                            List<EditDataPatchRecord> entries = null;
                            List<EditDataPatchField> fields = null;
                            List<EditDataPatchMoveRecord> moveEntries = null;
                            if (fromAsset == null)
                            {
                                if (!TryParseFields(tokenParser.Context, entry, out entries, out fields, out moveEntries, out string error))
                                    return TrackSkip(error);
                            }

                            // save
                            patch = new EditDataPatch(
                                path: path,
                                assetName: targetAsset,
                                conditions: conditions,
                                fromFile: fromAsset,
                                records: entries,
                                fields: fields,
                                moveRecords: moveEntries,
                                updateRate: updateRate,
                                contentPack: pack,
                                parentPatch: parentPatch,
                                monitor: this.Monitor,
                                normalizeAssetName: this.NormalizeAssetName,
                                tryParseFields: TryParseFields
                            );
                        }
                        break;

                    // edit image
                    case PatchType.EditImage:
                        {
                            // validate
                            if (fromAsset == null)
                                return TrackSkip($"must set the {nameof(PatchConfig.FromFile)} field for a {PatchType.Load} patch.");

                            // read patch mode
                            PatchMode patchMode = PatchMode.Replace;
                            if (!string.IsNullOrWhiteSpace(entry.PatchMode) && !Enum.TryParse(entry.PatchMode, true, out patchMode))
                                return TrackSkip($"the {nameof(PatchConfig.PatchMode)} is invalid. Expected one of these values: [{string.Join(", ", Enum.GetNames(typeof(PatchMode)))}]");

                            // read from area
                            TokenRectangle fromArea = null;
                            if (entry.FromArea != null && !this.TryParseRectangle(entry.FromArea, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.FromArea)), out string error, out fromArea))
                                return TrackSkip(error);

                            // read to area
                            TokenRectangle toArea = null;
                            if (entry.ToArea != null && !this.TryParseRectangle(entry.ToArea, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.ToArea)), out error, out toArea))
                                return TrackSkip(error);

                            // save
                            patch = new EditImagePatch(
                                path: path,
                                assetName: targetAsset,
                                conditions: conditions,
                                fromAsset: fromAsset,
                                fromArea: fromArea,
                                toArea: toArea,
                                patchMode: patchMode,
                                updateRate: updateRate,
                                contentPack: pack,
                                parentPatch: parentPatch,
                                monitor: this.Monitor,
                                normalizeAssetName: this.NormalizeAssetName
                            );
                        }
                        break;

                    // edit map
                    case PatchType.EditMap:
                        {
                            string error;

                            // read map properties
                            var mapProperties = new List<EditMapPatchProperty>();
                            if (entry.MapProperties?.Any() == true)
                            {
                                foreach (var pair in entry.MapProperties)
                                {
                                    LogPathBuilder localPath = path.With(nameof(entry.MapProperties), pair.Key);

                                    if (!tokenParser.TryParseString(pair.Key, immutableRequiredModIDs, localPath.With("key"), out error, out IManagedTokenString key))
                                        return TrackSkip($"{nameof(PatchConfig.MapProperties)} > '{pair.Key}' key is invalid: {error}");
                                    if (!tokenParser.TryParseString(pair.Value, immutableRequiredModIDs, localPath.With("value"), out error, out IManagedTokenString value))
                                        return TrackSkip($"{nameof(PatchConfig.MapProperties)} > '{pair.Key}' value '{pair.Value}' is invalid: {error}");

                                    mapProperties.Add(new EditMapPatchProperty(key, value));
                                }
                            }

                            // read map tiles
                            var mapTiles = new List<EditMapPatchTile>();
                            if (entry.MapTiles?.Any() == true)
                            {
                                for (int i = 0; i < entry.MapTiles.Length; i++)
                                {
                                    PatchMapTileConfig tile = entry.MapTiles[i];
                                    LogPathBuilder localPath = path.With(nameof(entry.MapTiles), i.ToString());
                                    string errorPrefix = $"{nameof(PatchConfig.MapTiles)} > entry #{i + 1}";

                                    // layer
                                    if (!tokenParser.TryParseString(tile.Layer, immutableRequiredModIDs, localPath.With(nameof(tile.Layer)), out error, out IManagedTokenString layer))
                                        return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.Layer)} is invalid: {error}");

                                    // position
                                    if (!this.TryParsePosition(tile.Position, tokenParser, immutableRequiredModIDs, localPath.With(nameof(tile.Position)), out error, out TokenPosition position))
                                        return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.Position)} is invalid: {error}");

                                    // tilesheet
                                    IManagedTokenString tilesheet = null;
                                    if (tile.SetTilesheet != null && !tokenParser.TryParseString(tile.SetTilesheet, immutableRequiredModIDs, localPath.With(nameof(tile.SetTilesheet)), out error, out tilesheet))
                                        return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.SetTilesheet)} is invalid: {error}");

                                    // index
                                    IManagedTokenString index = null;
                                    if (tile.SetIndex != null && !this.TryParseInt(tile.SetIndex, tokenParser, immutableRequiredModIDs, localPath.With(nameof(tile.SetIndex)), out error, out index))
                                        return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.SetIndex)} is invalid: {error}");

                                    // properties
                                    var tileProperties = new Dictionary<IManagedTokenString, IManagedTokenString>();
                                    if (tile.SetProperties?.Any() == true)
                                    {
                                        int p = 0;
                                        foreach (var pair in tile.SetProperties)
                                        {
                                            p++;
                                            if (!tokenParser.TryParseString(pair.Key, immutableRequiredModIDs, localPath.With(nameof(tile.SetProperties), "key"), out error, out IManagedTokenString key))
                                                return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.SetProperties)} > entry #{p + 1} > key is invalid: {error}");
                                            if (!tokenParser.TryParseString(pair.Value, immutableRequiredModIDs, localPath.With(nameof(tile.SetProperties), "value"), out error, out IManagedTokenString value))
                                                return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.SetProperties)} > entry #{p + 1} > value is invalid: {error}");

                                            tileProperties[key] = value;
                                        }
                                    }

                                    // remove
                                    IManagedTokenString remove = null;
                                    if (tile.Remove != null && !this.TryParseBoolean(tile.Remove, tokenParser, immutableRequiredModIDs, localPath.With(nameof(tile.Remove)), out error, out remove))
                                        return TrackSkip($"{errorPrefix} > {nameof(EditMapPatchTile.Remove)} is invalid: {error}");

                                    mapTiles.Add(new EditMapPatchTile(
                                        layer: layer,
                                        position: position,
                                        setIndex: index,
                                        setTilesheet: tilesheet,
                                        setProperties: tileProperties,
                                        remove: remove
                                    ));
                                }
                            }

                            // read from/to asset areas
                            TokenRectangle fromArea = null;
                            if (entry.FromArea != null && !this.TryParseRectangle(entry.FromArea, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.FromArea)), out error, out fromArea))
                                return TrackSkip(error);
                            TokenRectangle toArea = null;
                            if (entry.ToArea != null && !this.TryParseRectangle(entry.ToArea, tokenParser, immutableRequiredModIDs, path.With(nameof(entry.ToArea)), out error, out toArea))
                                return TrackSkip(error);

                            // validate
                            if (fromAsset == null && !mapProperties.Any() && !mapTiles.Any())
                                return TrackSkip($"must specify at least one of {nameof(entry.FromFile)}, {nameof(entry.MapProperties)}, or {nameof(entry.MapTiles)}");
                            if (fromAsset != null && entry.ToArea == null)
                                return TrackSkip($"must specify {nameof(entry.ToArea)} when using {nameof(entry.FromFile)} (use \"Action\": \"Load\" if you want to replace the whole map file)");

                            // save
                            patch = new EditMapPatch(
                                path: path,
                                assetName: targetAsset,
                                conditions: conditions,
                                fromAsset: fromAsset,
                                fromArea: fromArea,
                                toArea: toArea,
                                mapProperties: mapProperties,
                                mapTiles: mapTiles,
                                updateRate: updateRate,
                                contentPack: pack,
                                parentPatch: parentPatch,
                                monitor: this.Monitor,
                                reflection: this.Reflection,
                                normalizeAssetName: this.NormalizeAssetName
                            );
                        }
                        break;

                    default:
                        return TrackSkip($"unsupported patch type '{action}'");
                }

                // skip if not enabled
                // note: we process the patch even if it's disabled, so any errors are caught by the modder instead of only failing after the patch is enabled.
                if (!enabled)
                    return TrackSkip($"{nameof(PatchConfig.Enabled)} is false", warn: false);

                // save patch
                this.PatchManager.Add(patch, reindex);
                return true;
            }
            catch (Exception ex)
            {
                return TrackSkip($"error reading info. Technical details:\n{ex}");
            }
        }

        /// <summary>Parse the data change fields for an <see cref="PatchType.EditData"/> patch.</summary>
        /// <param name="entry">The change to load.</param>
        /// <param name="tokenParser">Handles low-level parsing and validation for tokens.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="entries">The parsed data entry changes.</param>
        /// <param name="fields">The parsed data field changes.</param>
        /// <param name="moveEntries">The parsed move entry records.</param>
        /// <param name="error">The error message indicating why parsing failed, if applicable.</param>
        /// <returns>Returns whether parsing succeeded.</returns>
        bool TryParseEditDataFields(PatchConfig entry, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out List<EditDataPatchRecord> entries, out List<EditDataPatchField> fields, out List<EditDataPatchMoveRecord> moveEntries, out string error)
        {
            entries = new List<EditDataPatchRecord>();
            fields = new List<EditDataPatchField>();
            moveEntries = new List<EditDataPatchMoveRecord>();

            bool Fail(string reason, out string outReason)
            {
                outReason = reason;
                return false;
            }

            // parse entries
            if (entry.Entries != null)
            {
                foreach (KeyValuePair<string, JToken> pair in entry.Entries)
                {
                    LogPathBuilder localPath = path.With(nameof(entry.Entries), pair.Key);

                    if (!tokenParser.TryParseString(pair.Key, assumeModIds, localPath.With("key"), out string keyError, out IManagedTokenString key))
                        return Fail($"{nameof(PatchConfig.Entries)} > '{pair.Key}' key is invalid: {keyError}", out error);
                    if (!tokenParser.TryParseJson(pair.Value, assumeModIds, localPath.With("value"), out string valueError, out TokenizableJToken value))
                        return Fail($"{nameof(PatchConfig.Entries)} > '{pair.Key}' value is invalid: {valueError}", out error);

                    entries.Add(new EditDataPatchRecord(key, value));
                }
            }

            // parse fields
            if (entry.Fields != null)
            {
                foreach (KeyValuePair<string, IDictionary<string, JToken>> recordPair in entry.Fields)
                {
                    var localPath = path.With(nameof(entry.Fields), recordPair.Key);

                    // parse entry key
                    if (!tokenParser.TryParseString(recordPair.Key, assumeModIds, localPath.With("key"), out string keyError, out IManagedTokenString key))
                        return Fail($"{nameof(PatchConfig.Fields)} > entry {recordPair.Key} is invalid: {keyError}", out error);

                    // parse fields
                    foreach (KeyValuePair<string, JToken> fieldPair in recordPair.Value)
                    {
                        // parse field key
                        if (!tokenParser.TryParseString(fieldPair.Key, assumeModIds, localPath.With(fieldPair.Key, "key"), out string fieldError, out IManagedTokenString fieldKey))
                            return Fail($"{nameof(PatchConfig.Fields)} > entry {recordPair.Key} > field {fieldPair.Key} key is invalid: {fieldError}", out error);

                        // parse value
                        if (!tokenParser.TryParseJson(fieldPair.Value, assumeModIds, localPath.With(fieldPair.Key, "value"), out string valueError, out TokenizableJToken value))
                            return Fail($"{nameof(PatchConfig.Fields)} > entry {recordPair.Key} > field {fieldKey} is invalid: {valueError}", out error);
                        if (value?.IsString == true && value.GetTokenStrings().SelectMany(p => p.LexTokens).OfType<LexTokenLiteral>().Any(p => p.Text.Contains("/")))
                            return Fail($"{nameof(PatchConfig.Fields)} > entry {recordPair.Key} > field {fieldKey} is invalid: value can't contain field delimiter character '/'", out error);

                        fields.Add(new EditDataPatchField(key, fieldKey, value));
                    }
                }
            }

            // parse move entries
            if (entry.MoveEntries != null)
            {
                int i = 0;
                foreach (PatchMoveEntryConfig moveEntry in entry.MoveEntries)
                {
                    LogPathBuilder localPath = path.With(nameof(entry.MoveEntries), i++.ToString());

                    // validate
                    string[] targets = new[] { moveEntry.BeforeID, moveEntry.AfterID, moveEntry.ToPosition };
                    if (string.IsNullOrWhiteSpace(moveEntry.ID))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > move entry is invalid: must specify an {nameof(PatchMoveEntryConfig.ID)} value", out error);
                    if (targets.All(string.IsNullOrWhiteSpace))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' is invalid: must specify one of {nameof(PatchMoveEntryConfig.ToPosition)}, {nameof(PatchMoveEntryConfig.BeforeID)}, or {nameof(PatchMoveEntryConfig.AfterID)}", out error);
                    if (targets.Count(p => !string.IsNullOrWhiteSpace(p)) > 1)
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' is invalid: must specify only one of {nameof(PatchMoveEntryConfig.ToPosition)}, {nameof(PatchMoveEntryConfig.BeforeID)}, and {nameof(PatchMoveEntryConfig.AfterID)}", out error);

                    // parse IDs
                    if (!tokenParser.TryParseString(moveEntry.ID, assumeModIds, localPath.With(nameof(moveEntry.ID)), out string idError, out IManagedTokenString moveId))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' > {nameof(PatchMoveEntryConfig.ID)} is invalid: {idError}", out error);
                    if (!tokenParser.TryParseString(moveEntry.BeforeID, assumeModIds, localPath.With(nameof(moveEntry.BeforeID)), out string beforeIdError, out IManagedTokenString beforeId))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' > {nameof(PatchMoveEntryConfig.BeforeID)} is invalid: {beforeIdError}", out error);
                    if (!tokenParser.TryParseString(moveEntry.AfterID, assumeModIds, localPath.With(nameof(moveEntry.AfterID)), out string afterIdError, out IManagedTokenString afterId))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' > {nameof(PatchMoveEntryConfig.AfterID)} is invalid: {afterIdError}", out error);

                    // parse position
                    MoveEntryPosition toPosition = MoveEntryPosition.None;
                    if (!string.IsNullOrWhiteSpace(moveEntry.ToPosition) && (!Enum.TryParse(moveEntry.ToPosition, true, out toPosition) || toPosition == MoveEntryPosition.None))
                        return Fail($"{nameof(PatchConfig.MoveEntries)} > entry '{moveEntry.ID}' > {nameof(PatchMoveEntryConfig.ToPosition)} is invalid: must be one of {nameof(MoveEntryPosition.Bottom)} or {nameof(MoveEntryPosition.Top)}", out error);

                    // create move entry
                    moveEntries.Add(new EditDataPatchMoveRecord(moveId, beforeId, afterId, toPosition));
                }
            }

            error = null;
            return true;
        }

        /// <summary>Normalize and parse the given condition values.</summary>
        /// <param name="name">The raw condition name.</param>
        /// <param name="value">The raw condition value.</param>
        /// <param name="tokenParser">Handles low-level parsing and validation for tokens.</param>
        /// <param name="lexer">Handles parsing raw strings into tokens.</param>
        /// <param name="path">The path to the condition from the root content file.</param>
        /// <param name="condition">The normalized condition.</param>
        /// <param name="immutableRequiredModIDs">The immutable mod IDs always required by this condition (if it's <see cref="ConditionType.HasMod"/> and immutable).</param>
        /// <param name="error">An error message indicating why normalization failed.</param>
        private bool TryParseCondition(string name, string value, TokenParser tokenParser, Lexer lexer, LogPathBuilder path, out Condition condition, out InvariantHashSet immutableRequiredModIDs, out string error)
        {
            bool Fail(string reason, out string setError, out Condition setCondition, out InvariantHashSet setImmutableRequiredModIDs)
            {
                setCondition = null;
                setImmutableRequiredModIDs = null;
                setError = reason;
                return false;
            }

            // parse condition key
            LexTokenToken keyLexToken;
            {
                // get lexical tokens
                ILexToken[] lexTokens = lexer.ParseBits(name, impliedBraces: true).ToArray();
                foreach (ILexToken cur in lexTokens)
                {
                    if (!tokenParser.Migrator.TryMigrate(cur, out error))
                        return Fail(error, out error, out condition, out immutableRequiredModIDs);
                }

                // parse condition key
                if (lexTokens.Length != 1 || !(lexTokens[0] is LexTokenToken lexToken))
                    return Fail($"'{name}' isn't a valid token name", out error, out condition, out immutableRequiredModIDs);
                keyLexToken = lexToken;
            }
            IManagedTokenString keyInputStr = new TokenString(keyLexToken.InputArgs, tokenParser.Context, path.With("key"));
            IInputArguments keyInputArgs = new InputArguments(keyInputStr);

            // get token
            IToken token = tokenParser.Context.GetToken(keyLexToken.Name, enforceContext: false);
            if (token == null)
                return Fail($"'{name}' isn't a valid condition; must be one of {string.Join(", ", tokenParser.Context.GetTokens(enforceContext: false).Select(p => p.Name).OrderBy(p => p))}", out error, out condition, out immutableRequiredModIDs);
            if (!tokenParser.TryValidateToken(keyLexToken, assumeModIds: null, out error))
                return Fail(error, out error, out condition, out immutableRequiredModIDs);

            // validate input
            if (!token.TryValidateInput(keyInputArgs, out error))
                return Fail(error, out error, out condition, out immutableRequiredModIDs);

            // parse values
            if (string.IsNullOrWhiteSpace(value))
                return Fail($"can't parse condition {name}: value can't be empty", out error, out condition, out immutableRequiredModIDs);
            if (!tokenParser.TryParseString(value, assumeModIds: null, path.With("value"), out error, out IManagedTokenString values))
                return Fail($"can't parse condition {name}: {error}", out error, out condition, out immutableRequiredModIDs);

            // validate token keys & values
            if (!values.IsMutable && !token.TryValidateValues(keyInputArgs, values.SplitValuesUnique(), tokenParser.Context, out string customError))
                return Fail($"invalid {keyLexToken.Name} condition: {customError}", out error, out condition, out immutableRequiredModIDs);

            // create condition
            condition = new Condition(name: token.Name, input: keyInputStr, values: values);

            // extract HasMod required IDs if immutable
            immutableRequiredModIDs = null;
            if (condition.IsReady && !condition.IsMutable && condition.Is(ConditionType.HasMod))
            {
                // contains
                if (condition.Input.ReservedArgs.TryGetValue(InputArguments.ContainsKey, out IInputArgumentValue contains))
                {
                    if (bool.TryParse(condition.Values.Value, out bool required) && required)
                        immutableRequiredModIDs = new InvariantHashSet(contains.Parsed);
                }

                // values
                else
                    immutableRequiredModIDs = condition.CurrentValues;
            }

            return true;
        }

        /// <summary>Parse a boolean value from a string which can contain tokens, and validate that it's valid.</summary>
        /// <param name="rawValue">The raw string which may contain tokens.</param>
        /// <param name="tokenParser">The  tokens available for this content pack.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="error">An error phrase indicating why parsing failed (if applicable).</param>
        /// <param name="parsed">The parsed value.</param>
        private bool TryParseBoolean(string rawValue, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out string error, out IManagedTokenString parsed)
        {
            // analyze string
            if (!tokenParser.TryParseString(rawValue, assumeModIds, path, out error, out parsed))
                return false;

            // validate & extract tokens
            if (parsed.HasAnyTokens)
            {
                // only one token allowed
                if (!parsed.IsSingleTokenOnly)
                {
                    error = "can't be treated as a true/false value because it contains multiple tokens.";
                    return false;
                }

                // parse token
                LexTokenToken lexToken = parsed.GetTokenPlaceholders(recursive: false).Single();
                IToken token = tokenParser.Context.GetToken(lexToken.Name, enforceContext: false);
                IInputArguments input = new InputArguments(new TokenString(lexToken.InputArgs, tokenParser.Context, path.With("input")));

                // check token options
                if (token == null)
                {
                    error = $"unknown token '{lexToken.Name}'.";
                    return false;
                }
                if (!token.HasBoundedValues(input, out InvariantHashSet allowedValues) || allowedValues == null || !allowedValues.All(p => bool.TryParse(p, out _)))
                {
                    error = "that token isn't restricted to 'true' or 'false'.";
                    return false;
                }
                if (token.CanHaveMultipleValues(input))
                {
                    error = "can't be treated as a true/false value because that token can have multiple values.";
                    return false;
                }
            }

            // parse text
            return true;
        }

        /// <summary>Parse a boolean <see cref="PatchConfig.Enabled"/> value from a string which can contain tokens, and validate that it's valid.</summary>
        /// <param name="rawValue">The raw string which may contain tokens.</param>
        /// <param name="tokenParser">The  tokens available for this content pack.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="error">An error phrase indicating why parsing failed (if applicable).</param>
        /// <param name="parsed">The parsed value.</param>
        private bool TryParseEnabled(string rawValue, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out string error, out bool parsed)
        {
            parsed = false;

            // analyze string
            if (!this.TryParseBoolean(rawValue, tokenParser, assumeModIds, path, out error, out IManagedTokenString tokenString))
                return false;

            // validate & extract tokens
            string text = rawValue;
            if (tokenString.HasAnyTokens)
            {
                // only one token allowed
                if (!tokenString.IsSingleTokenOnly)
                {
                    error = "can't be treated as a true/false value because it contains multiple tokens.";
                    return false;
                }

                // parse token
                LexTokenToken lexToken = tokenString.GetTokenPlaceholders(recursive: false).Single();
                IToken token = tokenParser.Context.GetToken(lexToken.Name, enforceContext: false);
                IInputArguments input = new InputArguments(new TokenString(lexToken.InputArgs, tokenParser.Context, path.With("input")));

                // check token options
                if (token == null || token.IsMutable || !token.IsReady)
                {
                    error = $"can only use static tokens in this field, consider using a {nameof(PatchConfig.When)} condition instead.";
                    return false;
                }

                text = token.GetValues(input).First();
            }

            // parse text
            if (!bool.TryParse(text, out parsed))
            {
                error = $"can't parse {tokenString.Raw} as a true/false value.";
                return false;
            }
            return true;
        }

        /// <summary>Parse a tokenizable position from its parts, and validate that it's valid.</summary>
        /// <param name="raw">The raw position to parse.</param>
        /// <param name="tokenParser">The tokens available for this content pack.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="error">An error phrase indicating why parsing failed (if applicable).</param>
        /// <param name="parsed">The parsed value.</param>
        private bool TryParsePosition(PatchPositionConfig raw, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out string error, out TokenPosition parsed)
        {
            bool TryParseField(string rawField, string name, out IManagedTokenString result, out string parseError)
            {
                if (!this.TryParseInt(rawField, tokenParser, assumeModIds, path.With(name), out parseError, out result))
                {
                    parseError = $"invalid {name}: {parseError}";
                    return false;
                }
                return true;
            }

            if (
                !TryParseField(raw.X, nameof(raw.X), out IManagedTokenString x, out error)
                || !TryParseField(raw.Y, nameof(raw.Y), out IManagedTokenString y, out error)
            )
            {
                parsed = null;
                return false;
            }

            parsed = new TokenPosition(x, y);
            return true;
        }

        /// <summary>Parse a tokenizable rectangle from its parts, and validate that it's valid.</summary>
        /// <param name="raw">The raw rectangle to parse.</param>
        /// <param name="tokenParser">The tokens available for this content pack.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="error">An error phrase indicating why parsing failed (if applicable).</param>
        /// <param name="parsed">The parsed value.</param>
        private bool TryParseRectangle(PatchRectangleConfig raw, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out string error, out TokenRectangle parsed)
        {
            bool TryParseField(string rawField, string name, out IManagedTokenString result, out string parseError)
            {
                if (!this.TryParseInt(rawField, tokenParser, assumeModIds, path.With(name), out parseError, out result))
                {
                    parseError = $"invalid {name}: {parseError}";
                    return false;
                }
                return true;
            }

            if (
                !TryParseField(raw.X, nameof(raw.X), out IManagedTokenString x, out error)
                || !TryParseField(raw.Y, nameof(raw.Y), out IManagedTokenString y, out error)
                || !TryParseField(raw.Width, nameof(raw.Width), out IManagedTokenString width, out error)
                || !TryParseField(raw.Height, nameof(raw.Height), out IManagedTokenString height, out error)
            )
            {
                parsed = null;
                return false;
            }

            parsed = new TokenRectangle(x, y, width, height);
            return true;
        }

        /// <summary>Parse an integer value from a string which can contain tokens, and validate that it's valid.</summary>
        /// <param name="rawString">The raw string which may contain tokens.</param>
        /// <param name="tokenParser">The  tokens available for this content pack.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="path">The path to the value from the root content file.</param>
        /// <param name="error">An error phrase indicating why parsing failed (if applicable).</param>
        /// <param name="parsed">The parsed value.</param>
        private bool TryParseInt(string rawString, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder path, out string error, out IManagedTokenString parsed)
        {
            parsed = null;

            // analyze string
            if (!tokenParser.TryParseString(rawString, assumeModIds, path, out error, out IManagedTokenString tokenString))
                return false;

            // validate tokens
            if (tokenString.HasAnyTokens)
            {
                // only one token allowed
                if (!tokenString.IsSingleTokenOnly)
                {
                    error = "can't be treated as a number because it contains multiple tokens.";
                    return false;
                }

                // parse token
                LexTokenToken lexToken = tokenString.GetTokenPlaceholders(recursive: false).Single();
                IToken token = tokenParser.Context.GetToken(lexToken.Name, enforceContext: false);
                IInputArguments input = new InputArguments(new TokenString(lexToken.InputArgs, tokenParser.Context, path.With("input")));

                // check token options
                bool isIntegerBounded =
                    token.HasBoundedRangeValues(input, out _, out _)
                    || (
                        token.HasBoundedValues(input, out InvariantHashSet allowedValues)
                        && allowedValues != null
                        && allowedValues.All(p => int.TryParse(p, out _))
                    );

                if (!isIntegerBounded)
                {
                    error = "that token isn't restricted to integers.";
                    return false;
                }
                if (token.CanHaveMultipleValues(input))
                {
                    error = "can't be treated as a number because that token can have multiple values.";
                    return false;
                }
            }

            parsed = tokenString;

            return true;
        }

        /// <summary>Prepare a local asset file for a patch to use.</summary>
        /// <param name="path">The asset path in the content patch.</param>
        /// <param name="tokenParser">Handles low-level parsing and validation for tokens.</param>
        /// <param name="assumeModIds">Mod IDs to assume are installed for purposes of token validation.</param>
        /// <param name="logPath">The path to the value from the root content file.</param>
        /// <param name="error">The error reason if preparing the asset fails.</param>
        /// <param name="tokenedPath">The parsed value.</param>
        /// <returns>Returns whether the local asset was successfully prepared.</returns>
        private bool TryPrepareLocalAsset(string path, TokenParser tokenParser, InvariantHashSet assumeModIds, LogPathBuilder logPath, out string error, out IManagedTokenString tokenedPath)
        {
            // normalize raw value
            path = path?.Trim();
            if (string.IsNullOrWhiteSpace(path))
            {
                error = $"must set the {nameof(PatchConfig.FromFile)} field for this action type.";
                tokenedPath = null;
                return false;
            }

            // tokenize
            if (!tokenParser.TryParseString(path, assumeModIds, logPath, out string tokenError, out tokenedPath))
            {
                error = $"the {nameof(PatchConfig.FromFile)} is invalid: {tokenError}";
                tokenedPath = null;
                return false;
            }

            // looks OK
            error = null;
            return true;
        }

        /// <summary>Get whether a patch was loaded directly or indirectly by a parent patch.</summary>
        /// <param name="parent">The parent patch.</param>
        /// <param name="child">The child patch.</param>
        private bool IsDescendant(IPatch parent, IPatch child)
        {
            for (IPatch cur = child.ParentPatch; cur != null; cur = cur.ParentPatch)
            {
                if (object.ReferenceEquals(cur, parent))
                    return true;
            }

            return false;
        }
    }
}
